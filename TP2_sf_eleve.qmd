---
title: "TP2 - Intro à la statistique spatiale 2A - sf" 
# description: ""  # Description ou objectif du document
format:
  pdf:
    documentclass: article
    # mainfont: "Times New Roman"
    # number-sections: true # Numéroter les sections du document
    # number-depth: 3
    # toc: true     Ajout un sommaire
    # toc-depth: 3   Profondeur de numérotation/TOC
    header-includes: |
      \usepackage[bottom]{footmisc}
    text: |
      \usepackage[dvipsnames]{xcolor}
      \usepackage{booktabs}
      \usepackage{hyperref}
      \usepackage{enumitem}
lang: fr
# from: markdown+emoji  # Format d'entrée pour le document (markdown avec support des emojis)
fontsize: 10pt
papersize: a4
geometry: top=1.5cm, bottom=1.5cm, left=2.5cm, right=2.5cm
# bibliography: references.bib
link-citations: true 
nocite: "@*"
---

------------------------------------------------------------------------

## **OBJECTIFS DU TP:**

-   Le but de ce TP est de se familiariser à la manipulation d'objets spaciaux, à l'aide du package `sf`. Vous trouverez un cheatsheet [ici](https://osf.io/an6b5/download)

-   Aﬁn d’utiliser une version de R plus récente (et une version du package sf plus récente aussi), vous travaillerez sur le datalab (plateforme du sspcloud, service de l’Insee) : <https://datalab.sspcloud.fr>. . Si ce n’est déjà fait, il vous faudra créer un compte utilisateur puis créer un service Rstudio.

-   Si besoin (ce ne sera pas le cas pour cette séance), les fonds disponibles sous “U:/Eleves/Cartographie/Fonds_carte”. **PS : Ce répertoire ne doit JAMAIS être votre répertoire de travail !** Il s’agit d’un répertoire où l’on met à disposition des fonds de carte au service de tout le monde. Leur modiﬁcation pénaliserait donc tous ses utilisateurs.

------------------------------------------------------------------------

### Exercice 1

0.  Commencer par créer votre répo github “tp_stats_spatiales”. Créer un service Rstudio sur le datalab en saisissant le lien https de votre repo Git (suivre la procédure "Github et le datalab" si besoin). Une fois le service ouvert, créer un projet qui pointe vers votre dossier intitulé “tp_stats_spatiales” (qui est normalement déjà présent à l'ouverture du service).

Charger ensuite les package sf et dplyr.

```{r, message = FALSE, warning = FALSE}
library(dplyr)
library(sf)
```

1.  Importer le fond communal "commune_francemetro_2021.gpkg" disponible dans le dossier "France_metro". Pour cela vous utiliserez la fonction `st_read` du package `sf`. Quelles informations apparaissent dans la console ?

```{r}
communes <- st_read("commune_francemetro_2021.gpkg")
```

2.  Faites un résumé/descriptif du contenu de l'objet importé, comme vous le feriez pour un dataframe.

```{r}
str(communes)
summary(communes)
```

3.  Afficher maintenant les dix premières lignes de la table et regarder la dernière colonne.

```{r}
head(communes, 10)
```

4.  Afficher le système de projection de la table en utilisant la fonction `st_crs`.

```{r}
st_crs(communes)
```

5.  Créer une table "communes_Bretagne" ne contenant que les communes bretonnes. Ne conserver que les colonnes (code, libelle, epc, dep, surf) en utilisant la fonction `select()` de `dplyr`. Votre table contient-elle uniquement les 5 variables sélectionnées ?

```{r}
communes_Bretagne <- communes %>% 
  select(code, libelle, epc, dep, surf) %>% 
  filter(dep %in% c("29", "35", "22", "56"))
```

6.  Assurez-vous que cette nouvelle table est toujours un objet `sf`.

```{r}
class(communes_Bretagne)
```

7.  Appliquer la fonction `plot` sur votre table. (Indice : l'argument `lwd` vous permet de jouer sur l'épaisseur des lignes).

```{r}
plot(communes_Bretagne)
```

8.  Faire la question précédente en utilisant la fonction `st_geometry()` dans votre plot.

```{r}
plot(st_geometry(communes_Bretagne))
```

9.  Créer une variable de surface appelée "surf2" en utilisant les fonctions `st_area()` sur votre variable de geometry. En quelle unité est la variable créée ?

```{r}
communes_Bretagne$surf2 <- st_area(communes_Bretagne$geom)
```

10. Modifier la variable créée pour la convertir en km².

```{r}
communes_Bretagne <- communes_Bretagne %>% 
  mutate(surf2 = surf2*10^-6)


```

11. Les variables `surf` et `surf2` sont-elles égales ? Pourquoi selon vous ?

```{r}

```

12. L'objectif est de créer une table départementale "dept_bretagne" sans doublons. Cette table devra contenir le code departement et la superficie du département. Représenter le nouveau fond sur une carte avec la fonction `plot()`.

```{r}
dept_bretagne <- communes_Bretagne %>% 
  group_by(dep) %>% 
  summarise(surface = sum(surf2)) %>% 
  select(dep, surface)

plot(dept_bretagne)


```

13. Constituer cette fois un fond départemental en utilisant les fonctions `summarise()` et `st_union()`. À la différence de la table précedemment créée, le fond ne contiendra que le code dept et la geometry (aucune variable numérique ne sera utilisée). Faire ensuite un plot de votre table pour vérifier que les geometry ont bien été regroupés par département.

```{r}
fond_dep <- communes_Bretagne %>% 
  group_by(dep) %>% 
  summarise(geom_union = st_union(geom))

plot(fond_dep)
```

14. Créer une table "centroid_dept_bretagne" contenant les centroïdes des départements bretons.

<!-- -->

a.  Quel est le type de géometrie associé à ces centroïdes ?

```{r}

centroid_dept_bretagne <- st_centroid(dept_bretagne) #données ponctuelles

centroid_dept_bretagne$geom
```

b.  Représenter les départements bretons et leurs centroïdes sur une même carte, avec deux appels à la fonction `plot()` et en ajoutant l'argument `add = TRUE` sur le second appel.

```{r}
plot(st_geometry(dept_bretagne))
plot(st_geometry(centroid_dept_bretagne), add = TRUE)
```

c.  Ajouter le nom du départment dans le fond de centroïdes. La variable aura pour nom `dept_lib`. Plusieurs solutions sont possibles, la plus propre étant d'utiliser une petite table de passage et de la fusionner avec le fond de centroïdes.

```{r}
dept_lib <- tibble(dep = c("22", "29", "35", "56"),
                   dep_lib = c("Côtes-d'Armor", "Finistère", "Ille-et-Vilaine", "Morbihan"))

centroid_dept_bretagne <- centroid_dept_bretagne %>% 
  left_join(dept_lib, by = "dep")
```

d.  Récupérer les coordonnées des centroïdes dans un data.frame appelé `centroid_coords` avec la fonction `st_coordinates()`. Observer l'objet obtenu. Ajouter ensuite les colonnes `dep` et `dep_lib` du fond de `centroid_dept_bret` avec la fonction `bind_cols()`. Vous ferez attention à ce que `centroid_coords` ne contienne pas de géométrie (Indice : utiliser `st_drop_geometry()`).

```{r}
centroid_coords <- st_coordinates(centroid_dept_bretagne)
str(centroid_coords)
#On obtient un data.frame avec seulement 2 cols: X et Y

centroid_coords <- centroid_coords %>% 
  bind_cols(
    centroid_dept_bretagne %>% 
    select(dep, dep_lib) %>% 
    st_drop_geometry() # On souhaite retirer la géometrie 
    )

str(centroid_coords)
```

e.  Représenter les départements, leur centroïde (comme en 14.b) et leur nom (avec la fonction `text()`) sur une seule carte.

```{r}
plot(st_geometry(dept_bretagne))
plot(st_geometry(centroid_dept_bretagne), add = TRUE, 
     pch = 16, #point plein noir
     col = "orangered")
text(
  x = centroid_coords$X,
  y = centroid_coords$Y,
  labels = centroid_coords$dep_lib,
  pos = 3, #placer l'étiquette au-dessus
  cex = 0.8,
  col = "orangered"
)

```

15. À l'aide de la fonction `st_intersects()`, retrouver dans quelle commune se situe le centroïde de chaque département breton.

```{r}
commune_centroid_Bretagne <- st_intersects(centroid_dept_bretagne, communes_Bretagne)

#Il s'agit d'une liste de longueur égale au nombre d'élements du 1er paramètre entré

str(commune_centroid_Bretagne)



commune_centroid_Bretagne <- unlist(commune_centroid_Bretagne)


#Pour afficher les communes qui contiennent les centroides
#En R base
communes_Bretagne[commune_centroid_Bretagne,]

#En dplyr:
communes_Bretagne %>%
  slice(commune_centroid_Bretagne) %>% 
  select(libelle)
  
```

16. Faire la même question avec la fonction `st_intersection()` puis avec la fonction `st_within()`. Quelles différences voyez-vous avec la fonction `st_intersects()` ?

```{r}
st_intersection(communes_Bretagne, centroid_dept_bretagne)
#Fonction dédiée à l'intersection des 2 gémoétries associées aux 2 objets sf
#Renvoi un data.frame/tibble

#Avec st_within, on regarde si le 1er objet est contenu dans le second. L'ordre des paramètres a donc une importance. 
st_within(centroid_dept_bretagne, communes_Bretagne)
#Renvoie une liste
```

17. Calculer la distance séparant les centroïdes des départements et leur chefs-lieux. Les chefs-lieux des départements bretons sont les communes de Saint-Brieuc (22), Quimper (29), Rennes (35) et Vannes (56). Vous utiliserez la fonction `st_distance()`.

```{r}
Q17 <- st_distance(centroid_dept_bretagne, 
            communes_Bretagne %>% 
              filter(libelle %in% c("Saint-Brieuc", "Quimper", "Rennes", "Vannes"))) %>% 
  data.frame() #ATTENTION, tibble() renverra une seule col

rownames(Q17) <- paste0("centroide ", centroid_dept_bretagne$dep)
colnames(Q17) <- c("Saint-Brieuc", "Quimper", "Rennes", "Vannes")

Q17
diag(as.matrix(Q17))
```

18. Quelles sont les communes à moins de 20 km (à vol d'oiseau) de chaque centroïde ?

<!-- -->

a.  Utilisez la fonction `st_buffer(x,dist)` pour créer une zone de 20 km autour des centroïdes. Vous ferez attention aux unités.

```{r}
buffer <- st_buffer(commune_centroid_Bretagne, dist = 2000)
```

b.  Représenter sur une carte la géométrie obtenue avec la fonction `plot()`.

```{r}
```

c.  Récupérez les communes comprises dans les tampons obtenus au 18.a avec la fonction `st_intersection()`.

```{r}
```

d.  Combien de communes sont concernées par département ?

```{r}
```

19. 

<!-- -->

a.  Changer le système de projection des communes bretonnes pour le mettre en WGS84 (EPSG=4326), avec la fonction `st_transform()`.

```{r}
```

b.  Représentez le fond ainsi produit.

```{r}
```

20. Recalculer l'aire des communes pour créer une variable `surf3`. Que se passe t'il ?

```{r}
```
